package lesson10;

/*
1. Цель примера — сгенерировать последовательность чисел от 0 до MAX_VALUE-1 и отправить ее группе потоков для обработки. Обработка в данном случае заключается в выводе полученного числа на консоль. Обмен данными между потоками с применением механизма notify/wait всегда должен происходить в два шага — на первом шаге отправитель должен убедиться, что его ждут (из-за негарантированности получения извещений), а на втором — отправить передаваемые данные. По этой причине для синхронизации обмена нам придется использовать два объекта-снхронизатора
2. Код, реализующий потоки-обработчики. Принимает в цикле переданные данные до получения маркера конца передачи, в качестве которого используется значение MAX_VALUE. Этот прием завершения работы потока мы более подробно разберем в одном  из следующих разделов.
3. Запуск потоков-обработчиков.
4. Оправка им сгенерированных чисел для обработки.
5. Отправка потокам маркера конца передачи. Количество переданных маркеров должно в точности соответствовать количеству запущенных потоков.
6. Код метода отправки числа. Первая критическая секция — для выполнения первого шага синхронизации («убедиться»).
7. Вместо конструкции if следует применять while, потому что при вызове метода wait (<8>) мы выходим из критической секции, и, по этой причине, не можем ожидать, что состояние переменных программы окажется тем же, что и до вызова метода wait.
9. Отметка факта, что передающая сторона убедилась в том, что ее ждут, и подготовилась к новой передаче
10. А вот теперь необходимо разместить передаваемые данные в переменную, доступную как передающему, так и приемному потоку (<11>), и сообщить, что ожидающий данные поток может их забрать (<12>).
13. Код метода получения числа. Данный метод является synchronized-методом, потому что написать схему синхронизации между одним передатчиком и множеством приемников данных на порядок сложнее, чем написать таковую для одного приемника и одного передатчика. Проще выстроить приемники в «очередь». Обратите внимание на то, что метод send не имеет описателя synchronized – он, во-первых, для передатчика не нужен (поскольку передатчик у нас ровно один), и, во-вторых, при его наличии мы просто не сможем выполнить операцию передачи (подумайте почему)
14. Обратите внимание — порядок входа в критические секции в передатчике и приемнике разный! Более того, если внимательно проанализировать код, можно обнаружить (с учетом особенностей метода wait), что ни в один момент времени ни передатчик, ни приемник не находятся в обоих критических секциях одновременно.
15. Нужно проверить, не готов ли уже передатчик передать данные (<16>), и, если да, разрешить ему передать данные (<17> и <18>)
19. Ожидать момента, когда передатчик сообщит о том, что переданные данные можно забрать
20. Забрать переданные данные.
*/
public class NotifyWaitSender {
	public static final int					THREAD_COUNT = 10;
	public static final int					MAX_VALUE = 20;
	public static final NotifyWaitSender	instance = new NotifyWaitSender();  

	private final Object		sendSync = new Object(), recvSync = new Object();	// <1>
	private int					value = 0;
	private boolean	awaited = false;
	
	
	public static void main(String[] args) throws InterruptedException {
		final Runnable	getter = new Runnable(){	// <2>
			@Override
			public void run() {
				int		value;
				
				System.err.println("Getter ["+Thread.currentThread().getName()+"] started...");
				try{while ((value = instance.get()) < MAX_VALUE) {
						System.err.println("Getter ["+Thread.currentThread().getName()+"] : "+value);
					}
				} catch (InterruptedException e) {
				}
				System.err.println("Getter ["+Thread.currentThread().getName()+"] ended");
			}
		};
		
		for (int index = 0; index < THREAD_COUNT; index++) {	// <3>
			new Thread(getter).start();
		}
		
		System.err.println("Start sender...");					// <4>
		for (int index = 0; index < MAX_VALUE; index++) {
			instance.send(index);
		}
		
		for (int index = 0; index < THREAD_COUNT; index++) {	// <5>
			instance.send(MAX_VALUE);
		}
		System.err.println("End sender.");
	}

	
	void send(int value) throws InterruptedException {
		synchronized(sendSync) {	// <6>
			while(!awaited) {		// <7>
				sendSync.wait();	// <8>
			}
			awaited = false;		// <9>
			synchronized(recvSync) {	// <10>
				this.value = value;		// <11>
				recvSync.notify();		// <12>
			}
		}
	}

	synchronized int get() throws InterruptedException {	// <13>
		synchronized(recvSync) {	// <14>
			synchronized(sendSync) {	// <15>
				if (!awaited) {			// <16>
					awaited = true;		// <17>
					sendSync.notify();	// <18>
				}
			}
			recvSync.wait();			// <19>
			return this.value;			// <20>
		}
	}
}